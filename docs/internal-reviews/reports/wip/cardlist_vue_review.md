# CardList.vue レビューレポート

## 実施日
2025-12-07

## レビュー対象
- ファイル: `src/components/CardList.vue`
- ファイルサイズ: 707行
- 変更回数: 32回（高頻度）

## レビュー観点
1. ソート複数キーの処理順序確認
2. displayOrder との連携確認
3. 大量カード（200+）時のパフォーマンス確認

---

## 発見事項

### 🔴 重大な問題

#### 1. ソート複数キーの実装が不完全

**問題箇所**: `src/components/CardList.vue:316-371` (sortCards関数)

**詳細**:
- コメント（33-37行）では「同値の場合はカード名で比較（五十音順）」と記載
- しかし実際の実装では、一部のソートでしか第2キーが実装されていない

**実装状況**:

| ソートキー | 第2キー実装 | 備考 |
|-----------|-----------|------|
| `release_asc/desc` | ❌ なし | cardIdでソート（第2キー不要） |
| `name_asc/desc` | ❌ なし | カード名でソート（第2キー不要） |
| `atk_asc/desc` | ❌ なし | **問題**: 同ATK値のカードの順序が不定** |
| `def_asc/desc` | ❌ なし | **問題**: 同DEF値のカードの順序が不定** |
| `level_asc/desc` | ❌ なし | **問題**: 同レベルのカードの順序が不定** |
| `attribute_asc/desc` | ✅ あり | 第2キー: cardId（発売日の降順） |
| `race_asc/desc` | ✅ あり | 第2キー: cardId（発売日の降順） |
| `code_asc/desc` | N/A | 元の配列順序をそのまま使用 |

**影響範囲**:
- ATK/DEF/レベルでソートした場合、同値のカードの表示順序が不安定
- ユーザー体験の一貫性が損なわれる

**推奨対応**:
```typescript
// 例: atk_descの場合
case 'atk_desc':
  return sorted.sort((a, b) => {
    const cmp = (b.atk ?? -1) - (a.atk ?? -1)
    // 第2キー: ATKが同値の場合はカード名で比較
    return cmp !== 0 ? cmp : (a.name || '').localeCompare(b.name || '')
  })
```

---

### 🟡 中程度の問題

#### 2. maxIndexMap のクリア処理が不明確

**問題箇所**: `src/components/CardList.vue:270` (maxIndexMap)

**詳細**:
- `maxIndexMap` (reactive Map) は各baseKey (`${card.cardId}-${card.ciid}`) の最大インデックスを追跡
- 新しいカード検索時やコンポーネントリセット時にクリアされるかどうかが不明確
- クリアされない場合、インデックスが際限なく増加する可能性

**影響範囲**:
- メモリリーク（長時間の使用でMapが肥大化）
- UUID生成の一貫性問題

**推奨対応**:
- カード配列が変更された時（props.cards の watch）に maxIndexMap をクリア
- または、コンポーネントのライフサイクルに応じてクリア処理を追加

---

#### 3. displayOrder との連携が不明確

**問題箇所**: CardList.vue全体

**詳細**:
- `useDeckEditStore()` をインポートしているが、`displayOrder` は直接使用されていない
- CardList.vue は検索結果の表示に使われており、デッキ編集の表示順序管理とは独立している可能性
- しかし、`cardsWithUuid` で生成されたUUIDがdeck-edit.tsのdisplayOrderと連携するかは不明

**影響範囲**:
- displayOrderとの連携が必要な場合、現在の実装では不十分
- 検索結果からデッキへのカード追加時の挙動が不明確

**推奨対応**:
- displayOrderとの連携が必要かどうかを明確化
- 必要な場合は連携ロジックを実装
- 不要な場合はドキュメントに明記

---

### 🟢 良好な点

#### 1. UUID管理の実装

**箇所**: `src/components/CardList.vue:266-393`

**評価**:
- WeakMap (`cardUuidMap`) を使用してカードオブジェクトとUUIDをマッピング
- reactive Map (`maxIndexMap`) で最大インデックスを追跡
- 新規カードには適切にインデックスが付与される（380-386行）
- **良好な設計**: メモリ管理が適切（WeakMapはGC可能）

---

#### 2. ソート関数の構造

**箇所**: `src/components/CardList.vue:316-371`

**評価**:
- ソート関数が明確にswitch文で分岐
- 各ソートパターンが独立して実装されており、保守性が高い
- `getCid` ヘルパー関数でcardIdをパース（319行）

---

## テストカバレッジ評価

**現在のテスト**: `tests/unit/components/CardList.test.ts`

**カバー済み**:
- ✅ リスト/グリッド表示モードの切り替え
- ✅ ソート選択肢の表示
- ✅ ソート順変更時のイベント発火
- ✅ sortOrderプロパティ変更時の選択値更新

**未カバー**:
- ❌ **ソート複数キーの処理順序**（同値時の第2キー処理）
- ❌ **displayOrderとの連携**
- ❌ **大量カード（200+）時のパフォーマンス**
- ❌ **UUID生成の一意性と永続性**
- ❌ **maxIndexMapのクリア処理**

---

## パフォーマンス評価

### 大量カード（200+）時の懸念

**評価箇所**: `src/components/CardList.vue:374-393` (cardsWithUuid computed)

**現在の実装**:
```typescript
const cardsWithUuid = computed(() => {
  const sorted = sortCards(props.cards, localSortOrder.value)
  return sorted.map((card) => {
    // UUID生成ロジック
    // ...
  })
})
```

**パフォーマンス分析**:
1. **ソート処理**: `Array.sort()` は O(n log n)、200枚程度なら問題なし
2. **map処理**: O(n)、各カードでWeakMap/Map lookup
3. **computed再計算**: カード配列やソート順が変わるたびに再計算

**結論**:
- 200+枚でも致命的なパフォーマンス問題は発生しないと予想
- しかし、1000+枚になると遅延の可能性あり
- **推奨**: パフォーマンステストの追加

---

## 推奨対応アクション

### 優先度: 高

1. **ソート複数キーの実装を完了**
   - atk, def, level ソートに第2キー（カード名）を追加
   - コメントと実装の一致を確認

2. **テストケースの追加**
   - 複数キーソートのテスト
   - 同値カードの順序確認テスト

### 優先度: 中

3. **maxIndexMap のクリア処理を実装**
   - カード配列変更時のクリアロジック追加
   - テストで確認

4. **displayOrder との連携を明確化**
   - 連携が必要かどうかを判断
   - ドキュメント更新

### 優先度: 低

5. **パフォーマンステストの追加**
   - 200+枚のカードでのソート処理時間計測
   - 必要に応じて最適化

---

## まとめ

### 総合評価: 🟡 中（改善推奨）

**理由**:
- ソート複数キーの実装が不完全（重大な問題）
- maxIndexMapのクリア処理が不明確
- テストカバレッジが不十分

**推奨アクション**:
1. ソート複数キーの実装を完了（最優先）
2. テストケースの追加
3. maxIndexMapのクリア処理を実装

**リスク評価**:
- **現在**: 中リスク（ユーザー体験の一貫性に影響）
- **対応後**: 低リスク

---

## 次のステップ

1. **即座に対応**: ソート複数キーの実装を完了
2. **v0.4.0リリース前**: テストケースの追加とmaxIndexMapクリア処理
3. **v0.4.1以降**: displayOrder連携の明確化とパフォーマンステスト
